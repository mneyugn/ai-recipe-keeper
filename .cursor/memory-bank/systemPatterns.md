# System Patterns: AI Recipe Keeper

## 1. Architecture Overview

The application follows a modern web architecture with a serverless backend and a dynamic frontend.

- **Frontend:** Built with [Astro](https://astro.build/) for static site generation and islands architecture. [React](https://react.dev/) is used for interactive UI components (components-as-islands).
- **Backend:** A set of serverless functions (Astro API routes) handles business logic.
- **Database:** [Supabase](https://supabase.com/), a backend-as-a-service platform, provides the PostgreSQL database, authentication, and auto-generated APIs.
- **AI Services:** Integrated with [OpenRouter](https://openrouter.ai/) to leverage various large language models for recipe extraction.

## 2. Key Design Patterns

- **Islands Architecture:** Most of the UI is static HTML, generated by Astro for performance. Interactive components are loaded as isolated "islands" of JavaScript, using React. This reduces the amount of client-side JavaScript.
- **Serverless Functions:** API endpoints are deployed as serverless functions, which are stateless and scale automatically. This simplifies backend management.
- **Dependency Injection (DI) with `tsyringe`:** The backend architecture utilizes `tsyringe` for managing dependencies. Services are decorated with `@injectable()` and their dependencies are injected via string-based tokens (e.g., `@inject("SupabaseClient")`) in the constructor. This pattern avoids circular dependencies that can arise from importing token objects.
- **Controller-Service Pattern:** API logic is separated into two layers. Controllers (`AuthController`, `RecipeController`, etc.) are responsible for handling the HTTP request/response cycle. Services (`AuthService`, `RecipeService`, etc.) contain the core business logic and are injected into controllers. This promotes separation of concerns and testability.
- **Request-Scoped DI Containers:** For dependencies that are stateful per-request (like the Supabase client, which needs user-specific cookies), a child DI container is created for each incoming API request using `createRequestContainer`. The container then resolves the required controller (e.g., `container.resolve(UserController)`), which in turn gets its dependencies injected. This ensures request isolation and prevents data leakage between concurrent users.
- **Middleware Error Handling:** A `withErrorHandler` wrapper is used on all API route handlers. This middleware centralizes error handling by catching any thrown `ApiError` or other exceptions and formatting them into a standardized JSON error response, keeping the controller logic clean and focused on the happy path.
- **Repository Pattern:** Services encapsulate data access logic, separating business logic from data persistence concerns. For instance, `RecipeService` handles all database operations for recipes.
- **Environment-based Configuration:** Application configuration (API keys, database URLs) is managed through environment variables (`.env` files), separating configuration from code.

## 3. Data Flow

1.  **User Interaction:** A user interacts with the React components in the browser.
2.  **API Request:** The frontend makes API calls to the Astro API routes.
3.  **Authentication:** Astro middleware verifies the user's session using Supabase Auth.
4.  **Business Logic:** The API route executes business logic (e.g., calling a service).
5.  **Database Access:** Services interact with the Supabase database.
6.  **AI Extraction:** For recipe extraction, the backend calls the OpenRouter API.
7.  **API Response:** The API route returns a JSON response to the frontend.
8.  **UI Update:** The frontend updates the UI based on the response.
